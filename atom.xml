<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Yet Another Android Blog]]></title>
  <link href="http://oleksandr-yefremov.github.io/atom.xml" rel="self"/>
  <link href="http://oleksandr-yefremov.github.io/"/>
  <updated>2014-09-15T11:31:51+03:00</updated>
  <id>http://oleksandr-yefremov.github.io/</id>
  <author>
    <name><![CDATA[Oleksandr Yefremov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fragment FTW!]]></title>
    <link href="http://oleksandr-yefremov.github.io/blog/2014/09/14/draft-fragment/"/>
    <updated>2014-09-14T23:04:06+03:00</updated>
    <id>http://oleksandr-yefremov.github.io/blog/2014/09/14/draft-fragment</id>
    <content type="html"><![CDATA[<p>There is a lot of stuff written already about Activity and Fragment lifecycle and how to manage state and object retaining properly. So this is just a recap for myself, rather than tutorial.</p>

<p>Let&rsquo;s take a look at <strong>Activities</strong> and their destiny. There are 3 cases when and how activity can be destroyed.</p>

<!-- more -->


<p><strong>First case</strong>: User enters activity <em>A</em>, from there goes to <em>B</em>, and then navigates back to <em>A</em>. Android won&rsquo;t save any instance state of activity <em>B</em> because user won&rsquo;t need this particular instance anymore. When he comes again to <em>B</em> he will get a fresh instance.</p>

<p><strong>Second case</strong>: User enters activity <em>A</em> and rotates screen (or other configuration change occurs). Android has to recreate activity, so first it calls <code>onSaveInstanceState(Bundle outState)</code>, destroys <em>A</em> and creates new instance, then calls <code>onRestoreInstanceState(Bundle savedInstanceState)</code> to restore state of views (the same can be done in <code>onCreate(Bundle savedInstanceState)</code>).</p>

<p><strong>Third case</strong>: User enters activity <em>A</em>, from there goes to <em>B</em>, <em>C</em>, <em>D</em>… up the activity stack. At some point Android kills <em>A</em> to reclaim memory (or because you turned on useful feature <em>Developer options -> Don&rsquo;t keep activities</em>). Because user may eventually come back to <em>A</em>, system saves <em>A</em>&rsquo;s state before killing and later recreates it with <code>savedInstanceState</code>.<br/>
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<p>
Now let&rsquo;s take a look at how <strong>Fragments</strong> live. Fragment is tightly coupled to activity&rsquo;s lifecycle. It also has methods <code>onSaveInstanceState()</code>, <code>onRestoreInstanceState()</code> and knows how to save its internal state…
Types of dependency injection:
* constructor injection (good one. Exposes all dependencies to use a client.)
However, it works with <code>setRetainInstance</code>, because fragment is saved in whole, but fails in case 3, cause Fragment is recreated with Fragment()
* setter injection (not good cause, <code>setObject1()</code>, <code>setObject2()</code>, if 1st is set and 2nd is not, incomplete state)
* interface (same as SI, and too complicated, also is testable?)
*</p>
]]></content>
  </entry>
  
</feed>
